---
title: "NMDS and PCoA plots Lagoa dos Ingleses "
author: "Gabriel Mendes"
date: "01/2024"
---
  
# Carregando bibliotecas ----
{
  library(Biostrings)
  library(DECIPHER)
  library(factoextra)
  library(future)
  library(ggh4x)
  library(ggordiplots)
  library(ggord)
  library(ggpubr)
  library(ggvegan)
  library(Matrix)
  library(phyloseq)
  library(ShortRead)
  library(stringr)
  library(vegan)
  library(tidyverse)
  library(dplyr)
}

# Caminhos ----
{
  prjct_path <- "~/projetos/lagoa_ingleses/"
  results_path <- paste0(prjct_path,"/results")
  figs_path <- paste0(results_path,"/figuras")
  tbl_path <- paste0(prjct_path,"/tabelas/raw/run_2_4_5")
  prjct_radical <- "eDNA_Lagoa-dos-Ingleses"
}

# Obtencao de dados ----

# All the data was generated by the 012024_post_plot.r code

## NMDS ----

# NMDS (Non-Metric Multidimensional Scaling), ou Escalonamento Multidimensional Não 
# Métrico, é uma técnica de análise multivariada utilizada para visualizar a semelhança 
# ou dissimilaridade entre objetos ou observações em um conjunto de dados. O NMDS é 
# particularmente útil quando os dados não possuem uma estrutura linear clara e quando 
# a distância entre os pontos não pode ser representada de forma métrica.

# Converter planilha de identificações por ponto para o formato Amostras X IDs
  {
  # Função necessária para juntar as abds da tabela em IDs
  sum_uniq <- function(vec) {
    if (is.character(vec)) {
      suniq <- BiocGenerics::unique(vec)
    }
    if (is.numeric(vec)) {
      suniq <- sum(vec)
    }
    return(suniq)
  }
  
  # Número de linhas (IDs diferentes) por amostra
  fish_ID_tbl$Sample %>% table()
  
  fish_ID_tbl %>% colnames()
  
  # FINAL_tbl_IDs <- grouped_by_ID_BLASTid %>%
  # FINAL_tbl_IDs <- fish_ID_tbl %>%
  FINAL_tbl_IDs_t <- grouped_filt %>%
    filter(expedition %in% c("Novembro 2021")) %>% 
    # filter(Year %in% c("2021")) %>% # definir qual ano entrara na analise
    # filter(RRA >= 0.05) %>% # definicao de qual threshold de abundancia sera usado
    # filter(New_name %in% c("Ponte", "Fundacao")) %>% 
    # filter(!Sample %in% c("L2_dez20")) %>% # amostra problematica
    select(c("Sample", "Curated ID", "year", "Nivel", "new_name", "filter", "RRA")) %>% 
    pivot_wider(id_cols = c("Sample", "year", "Nivel", "new_name", "filter"),
                names_from = `Curated ID`,
                values_from = `RRA`,
                values_fn = sum_uniq,
                names_sort = TRUE,
                names_prefix = "ID_") %>% 
    relocate(c("Sample", "year", "Nivel", "filter", "new_name", starts_with("ID_"))) %>%  
    mutate(across(starts_with("ID_"), replace_na, replace = 0)) %>% 
    mutate("new_name" = as.factor(new_name)) %>% 
    mutate("Nivel" = as.factor(Nivel)) 
  
  # Verificando a soma das linhas
  FINAL_tbl_IDs_t %>% select(starts_with(match = "ID_")) %>% rowSums(na.rm = TRUE)
}

#  Rodando o NMDS
  
    # Preparar dados para entrada no pacote vegan
    colnames(FINAL_tbl_IDs_t)
    
    FINAL_tbl_IDs_t$`Sample` %>% unique() %>% sort()
    
    all_IDs_NMDS_tbl_t <- FINAL_tbl_IDs_t %>% 
      mutate("Sample number" = 0) %>% 
      relocate("Sample number" )
    
    # Associar números de amostra aos nomes de amostra
    for (sample in 1:nrow(all_IDs_NMDS_tbl_t)) {
      all_IDs_NMDS_tbl_t$`Sample number`[sample] <- sample
    }
    
    # Ordenar dataframe usado no NMDS
    all_IDs_NMDS_df_t <- all_IDs_NMDS_tbl_t %>%
      # mutate(Nivel = ifelse(Nivel == "Cheio", "Full", "Empty")) %>%
      as.data.frame()
    
    # Nomear linhas como números de amostra e remover coluna
    row.names(all_IDs_NMDS_df_t) <- all_IDs_NMDS_df_t$`Sample number`
    
    # Corrigir nomes das espécies para evitar problemas na plotagem
    colnames(all_IDs_NMDS_df_t)
    colnames(all_IDs_NMDS_df_t)[7:ncol(all_IDs_NMDS_df_t)] <- colnames(all_IDs_NMDS_df_t)[7:ncol(all_IDs_NMDS_df_t)] %>%
      str_replace_all(pattern = " ", replacement = "_") %>% 
      str_replace_all(pattern = "\\.", replacement = "") %>% 
      str_replace_all(pattern = "\\(", replacement = "") %>% 
      str_replace_all(pattern = "\\)", replacement = "")
    
## PCoA ----
  
  # Dados
    ## Usando a tabela all_IDs_NMDS_df_ gerada para o NDMDS
  
  ## Executando o PCoA
  
  #Criando a Matriz de distancia
  pcOa_dist <- vegan::vegdist(x = all_IDs_NMDS_df_t[,7:ncol(all_IDs_NMDS_df_t)],
                              method = "jaccard",
                              binary = TRUE)
  
  pcOa <- cmdscale(pcOa_dist, eig = TRUE)
  
  ordiplot(pcOa, display = 'sites', type = 'text')
  
  # Espécies 
  
  # Fazer o fit das espécies para identificar a significância delas na explicação dos agrupamentos. 
  # Esse é o passo que mais demora quando com muitas amostras e espécies.
  meta.spp.fit <- envfit(pcOa, 
                         all_IDs_NMDS_df_t[,7:ncol(all_IDs_NMDS_df_t)], 
                         permutations = 999) # this fits species vectors
  
  # Obter valores de p para as espécies
  sps_pvals <- tibble("IDs" = names(meta.spp.fit$vectors$pvals),
                      "p-value" = meta.spp.fit$vectors$pvals)
  
  spp.scrs <- as.data.frame(scores(meta.spp.fit, display = "vectors")) %>%
    mutate("IDs" = rownames(.)) %>%
    left_join(y = sps_pvals, by = "IDs")
  
  {
    spp.scrs$IDs <- gsub("ID_", "", spp.scrs$IDs)
    spp.scrs$IDs <- gsub("_", " ", spp.scrs$IDs)
    } 
  
  # Selecionar espécies significativas
  sig.spp.scrs <- spp.scrs 
  # %>%
  #   filter(`p-value` <=
  #            0.05) # definir p-value aqui!
  
  # Pontos amostrais
  
  #Definir os valores de PCoA1 e PCoA2, e os metadados de cada amostra/ponto amostral
  site.scrs <- as.data.frame(scores(pcOa, display = "sites"))
  
  colnames(site.scrs) <- c("PCoA1", "PCoA2")
  
  site.scrs <- site.scrs %>% 
    mutate("Sample number" = as.double(row.names(.))) %>%
    left_join(y = all_IDs_NMDS_df_t[, c("Sample number",
                                      "Sample",
                                      "Nivel",
                                      "new_name",
                                      "filter"
    )],
    by = "Sample number")
  
  # Determinar centroides
  scrs <- scores(pcOa, display = "sites")
  
  cent <- aggregate(scrs ~ filter, data = site.scrs, FUN = "mean")
  
  # Calcular elipses
  PCoA <- data.frame("PCoA1" = pcOa$points[, 1],
                     "PCoA2" = pcOa$points[, 2],
                     "filter" = as.factor(all_IDs_NMDS_df_t$filter), check.names = FALSE)
  
  PCoA.mean <- aggregate(PCoA[, 1:2], list(group = PCoA$filter), "mean")

# Elipses

  plot(all_ps_vegan_ord_meta)
  ordiplot(pcOa, display = 'sites', type = 'text')
  
  # Sobrepor as elipses
  ord <- ordiellipse(ord = pcOa, 
                     groups = all_IDs_NMDS_df_t$filter,
                     display = "sites",
                     kind = "ehull", conf = 0.95, label = T)
  
  
  # Funcao do vegan de calcular elipses
  veganCovEllipse <-function (cov, center = c(0, 0), scale = 1, npoints = 100) 
  {
    theta <- (0:npoints) * 2 * pi/npoints
    Circle <- cbind(cos(theta), sin(theta))
    t(center + scale * t(Circle %*% chol(cov)))
  }
  
  df_ell <- data.frame()
  
  for(g in levels(PCoA$filter)){
    print(g)
    df_ell <- 
      rbind(df_ell, 
            cbind(as.data.frame(with(PCoA[PCoA$filter==g,],
                                     veganCovEllipse(
                                       ord[[g]]$cov,
                                       ord[[g]]$center,
                                       ord[[g]]$scale))),
                  filter=g))}

  # Configurar plot PCoA
  
  # Definir paleta de cores

  cores <- c("#f1c232",
             "#3381b1")
  
  # Plot
  {
    PCoA_MCE_Sterivex <-
      ggplot(data = site.scrs,
             aes(x=PCoA1, 
                 y=PCoA2)) +
      
      # Elipses 
      ggforce::geom_mark_ellipse(inherit.aes = FALSE,
                                 data = df_ell,
                                 aes(x = Dim1,
                                     y = Dim2,
                                     group = filter,
                                     label = filter,
                                     col = filter,
                                     fill = filter
                                 ),
                                 alpha=0.10,
                                 # n = 200,
                                 linetype=2,
                                 expand = 0,
                                 label.fontsize = 14,
                                 con.cap = 0.1
      ) +
      # Niveis amostrais
      geom_point(aes(x=PCoA1,
                     y=PCoA2,
                     fill = filter,
                     # label = `Sampling unit`,  #descomentar se quiser exibir os nomes dos `Sampling sites`s
                     col=filter,
                     group = filter,
                     shape = new_name),
                 stroke = 0.5,
                 alpha = 0.75,
                 size = 3) +
      
      # Nomes dos `Sampling sites`s amostrais
      ggrepel::geom_text_repel(aes(label = new_name),  #descomentar bloco se quiser exibir os nomes dos pontos
                               # hjust=0.5,
                               # vjust=2.75,
                               size=4.5,
                               direction = "both",
                               segment.size = 0.25,
                               segment.alpha=0.1,
                               # min.segment.length = 1.5,
                               force = 3,
                               max.overlaps = 100,
                               fontface = "bold") +
      
      # # Vetores das IDs
      # geom_segment(data = sig.spp.scrs, aes(x = 0,
      #                                       xend = Dim1,
      #                                       y = 0,
      #                                       yend = Dim2),
      #              arrow = arrow(length = unit(0.1, "cm")),
      #              colour = "grey30",
      #              alpha = 0.5,
      #              lwd = 0.3) + #add vector arrows of significant species
      # 
      # # Nomes das IDs
      # ggrepel::geom_text_repel(data = sig.spp.scrs,
      #                          aes(x=Dim1, y=Dim2, label = IDs),
      #                          size = 3.5,
      #                          alpha = 0.75,
      #                          direction = "both",
      #                          segment.size = 0.25,
      #                          segment.alpha = 0.1,
      #                          max.overlaps = 100) +
      
      # Centroides
      geom_point(data = cent,
                 aes(x = Dim1,
                     y = Dim2, # colour = filter,
                     fill = filter
                 ),
                 size = 8,
                 colour = "#222222",
                 alpha = 0.75,
                 shape  = 13
      ) + 
      coord_fixed(expand = c(0.5))+
      theme_light() +
      theme(
        panel.background = element_blank(),
        # panel.grid.major = element_blank(),
        panel.grid.major = element_line(color = "grey",
                                        size = 0.2,
                                        linetype = 1),
        # axis.ticks = element_line(color = "grey"),
        axis.ticks = element_blank(),
        axis.text = element_text(color = "black"),
        axis.title = element_text(color = "black", size = rel(1.2)),
        # legend.background = element_blank(),
        # legend.key = element_blank(),
        legend.text = element_text(color = "black"),
        legend.title = element_text(color = "black", size = rel(1.2)),
        plot.title = element_text(color = "black", size = rel(1.5)),
        plot.subtitle = element_text(color = "black", size = rel(1.2))) +
      theme(plot.title = element_text(size = 14, face = "bold"),
            axis.text.x = element_text(size = 12),
            axis.text.y = element_text(size = 12),
            axis.title.x = element_text(size = 13, face = "bold"),
            axis.title.y = element_text(size = 13, face = "bold"),
            legend.text = element_text(size = 12),
            legend.title = element_text(size = 13),
            # legend.position = "bottom"
      ) +
      labs(x = "PCoA1 53.34%",
           y = "PCoA2 18,77%",
           title = "Composição da ictiofauna",
           # subtitle = "Filtro MCE versus Sterivex") +
           # subtitle = "Stress: ",format(round(all_ps_vegan_ord_meta$stress))
           ) +
      scale_fill_manual(values = cores) +
      scale_colour_manual(values = cores) 
    # + scale_fill_manual(values = viridis::turbo(n = 5)) # cores das formas das samples/pontos
    
    PCoA_MCE_Sterivex
  }
  
  # Salvar em pdf 
  ggsave(plot = PCoA_MCE_Sterivex, 
         filename = paste("/home/gabriel/projetos/lagoa_ingleses/results/figuras/2024/",
                          "PCoA_MCE_Sterivex_clean", "-", Sys.Date(), ".pdf", sep = ""),
         device = "pdf",
         units = "cm",
         height = 25,
         width = 25,
         dpi = 600)
  
## Permanova ----
  
  ## Primeiro e necessario gerar uma matriz de distancias para plotar as amostras
  ## e em seguida testar a assumpcao de que os dados dispersos formam grupos bem definidos.
  
  # Distance matrix
  
  pcOa_mtx <-  as.data.frame(as.matrix(pcOa_dist)) # gerado anteriormente para realizar o plot PCoA
  
  #Assumptions
  
  Dispersion <- betadisper(pcOa_dist, group = all_IDs_NMDS_df_$filter, type = "centroid") # testando a dispercao
  
  plot(Dispersion)
  
  anova(Dispersion)
  
  #Test
  
  perma_test <- adonis2(pcOa_mtx ~ as.factor(all_IDs_NMDS_df_$filter), data = pcOa_mtx,
                   permutations=9999)
  perma_test
  
  